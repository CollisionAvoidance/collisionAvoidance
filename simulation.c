/*
* EC463 Senior Design Project
* Group 6: Collision Avoidance
* Simulation
*/

// create three cars
// Call algo (car1)
// Call algo (car2)
// Call algo (car3)

// take output1, output2, output3 files (from algorithms)
// calculate position at each timestamp based on data
// combine results into a big file -> input for visualization


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "functions.h"
#include "collision_detection.h"
#include "collision_avoidance.h"

#define MAX_LINE_SIZE 265
#define TIMESTAMP_NUM 100
#define NUM_EVENTS 4

//	NUM_EVENTS is the number of events for each algorithm output,
//	so the number of entries in the result arrays		
//	4 events happen at times: 
//	1)t=0: Initial position and constant velocity
// 	2)t=t_start: Car starts to accelerate ACCELERATION_DISTANCE away from intersection
//	3)t=t_stop/t_enter: Car stops accelerating and enters the intersection
//	4)t=t_exit: Car exits the intersection

struct car_results {
	numbers * time;
	numbers * px;
	numbers * py;
	numbers * vx;
	numbers * vy;
	numbers * ax;
	numbers * ay;
};


/* Allocates memory and set car parameters */
void initialize_cars(struct car ** cars) {

	//car "constructor": id, px, py, vx, vy, x_enter, y_enter, x_exit, y_exit, intent
/*	
	// SCENARIO 1
	struct car * A = new_car("DOWN", 17.5, 0, 0, 2.4, 17.5, 10, 17.5, 20, straight);
	struct car * B = new_car("LEFT", 0, 12.5, 3.4, 0, 10, 12.5, 20, 12.5, straight);
	struct car * C = new_car("RIGHT", 30, 17.5, -1.9, 0, 20, 17.5, 12.5, 10, left);

*/
	// SCENARIO 2
	struct car * A = new_car("DOWN", 17.5, 0, 0, 2.5, 17.5, 10, 17.5, 20, straight);
	struct car * B = new_car("LEFT", 0, 12.5, 3.5, 0, 10, 12.5, 20, 12.5, straight);
	struct car * C = new_car("RIGHT", 30, 17.5, -2, 0, 20, 17.5, 12.5, 10, left);
/*
	// SCENARIO 3
	struct car * A = new_car("DOWN", 17.5, 0, 0, 2.5, 17.5, 10, 17.5, 20, straight);
	struct car * B = new_car("LEFT", 0, 12.5, 3.5, 0, 10, 12.5, 20, 12.5, straight);
	struct car * C = new_car("UP", 12.5, 30, 0, -2, 12.5, 20, 12.5, 10, left);

	// Zero collisions - moving forward
	struct car * A = new_car("A", 17.5, 0, 0, 2.1, 17.5, 10, 17.5, 20, straight);
	struct car * B = new_car("B", 0, 12.5, 1.9, 0, 10, 12.5, 20, 12.5, straight);
	struct car * C = new_car("C", 30, 17.5, -4.5, 0, 20, 17.5, 12.5, 10, left);

	struct car * A = new_car("DOWN", 116.7, 0, 0, 14, 116.7, 66.7, 116.7, 133.3, straight);
	struct car * B = new_car("LEFT", 0, 83.3, 23.3, 0, 66.7, 83.3, 133.3, 83.3, straight);
	struct car * C = new_car("RIGHT", 200, 116.7, -30, 0, 133.3, 116.7, 83.3, 66.7, left);
*/

	cars[0] = A;
	cars[1] = B;
	cars[2] = C;

}

/* Allocates memory for one results array */
struct car_results * new_result() {

  	struct car_results * newRes = malloc(sizeof(struct car_results));
  	newRes->time = malloc(NUM_EVENTS*sizeof(numbers));
	newRes->px = malloc(NUM_EVENTS*sizeof(numbers));
	newRes->py = malloc(NUM_EVENTS*sizeof(numbers));
	newRes->vx = malloc(NUM_EVENTS*sizeof(numbers));
	newRes->vy = malloc(NUM_EVENTS*sizeof(numbers));
	newRes->ax = malloc(NUM_EVENTS*sizeof(numbers));
	newRes->ay = malloc(NUM_EVENTS*sizeof(numbers));
  	return newRes;
}


/* Allocates memory for the array of resuls of the three cars */
void initialize_results(struct car_results ** res_array) {

	struct car_results * A = new_result();
	struct car_results * B = new_result();
	struct car_results * C = new_result();
	res_array[0] = A;
	res_array[1] = B;
	res_array[2] = C;

}


/* Identifies an element and places it in its corresponding array */
void identify_elem (struct car_results * result, int line_index, int token_index, char * token_str) {

	numbers element  = atof(token_str);		// Cast string token into a double

	switch (token_index) {		// Identify the category of the element and store it accordingly
		case 0:
			result->time[line_index] = element;
			break;
		case 1:
			result->px[line_index] = element;
			break;
		case 2:
			result->py[line_index] = element;
			break;
		case 3:
			result->vx[line_index] = element;
			break;
		case 4:
			result->vy[line_index] = element;
			break;
		case 5:
			result->ax[line_index] = element;
			break;
		case 6:
			result->ay[line_index] = element;
			break;
	}
}



/* 	Opens the three files generated by the individual algorithms
* 	and parses results, storing them in arrays */
void parse_results (struct car ** car_array, struct car_results ** result_array) {
	

	FILE * fp;
	char * line = NULL;
    size_t len = MAX_LINE_SIZE;
    ssize_t read;

    int line_counter, token_counter;

	// For each car
    int i;
	for (i=0; i<CAR_NUM; i++) {

		char filename [MAX_LINE_SIZE] = "inputs";		// Construct the customized file name "inputsID.txt"
		strcat(filename, car_array[i]->id);
		strcat(filename, ".txt");

		fp = fopen(filename,"r");				// Open the file for reading
		

		//printf("Opening file %s\n", filename);

		// For each line in the car's file
		line_counter = 0;
		while ((read = getline(&line, &len, fp)) != -1) { 	// get a new line from file
			
			token_counter = 0;
			char * token;
			token = strtok (line," ");	// Get first token
			while (token != NULL) {			// Get new items in the line that are separated by whitespaces

				char *newline = strchr(token, '\n');
				if (newline) 
					*newline = 0;			// If token contails newline char, get rid of it

				identify_elem(result_array[i], line_counter, token_counter, token);	 // Store token in corresponding array

				token_counter++;
			    token = strtok (NULL, " ");
			}
			line_counter++;
		}
	}
	fclose(fp);			// Close file
}


/* 	Compares the last event for all cars
*	and selects the one that happens the latest */
numbers max_t_exit(struct car_results ** car_results) {

	numbers max = 0;
	int i;
	for (i=0; i<CAR_NUM; i++) {
		if (car_results[i]->time[NUM_EVENTS-1] > max) {
			max = car_results[i]->time[NUM_EVENTS-1];
		}
	}
	return max;
}

/* Returns x position of car at time t */
numbers get_x_at_t (struct car_results * car, numbers t) {

	int event = 0;
	
	// Select corresponding event from input time array
	int i = 1; 
	while ((i< NUM_EVENTS)&&(t > car->time[i])) {
		event = i;
		i++;
	}
	// x = x0 + v0*t + 0.5*a*t^2
	return car->px[event] + (car->vx[event])*(t-car->time[event]) + 0.5*(car->ax[event])*(t-car->time[event])*(t-car->time[event]);
	printf("t = %.2f, (x) = %.2f, (vx) = %.2f, a = %.2f\n", t, car->px[event], car->vx[event], car->ax[event]);
}


/* Returns y position of car at time t */
numbers get_y_at_t (struct car_results * car, numbers t) {

	int event = 0;
	
	// Select corresponding event from input time array
	int i = 1; 
	while ((i< NUM_EVENTS)&&(t > car->time[i])) {
		event = i;
		i++;
	}	
	return car->py[event] + car->vy[event]*(t-car->time[event]) 
		+ 0.5*car->ay[event]*(t-car->time[event])*(t-car->time[event]);
}


/* 	Calculates positions for the three cars at each timestamp and 
* 	writes them to an output file called "inputs.txt" */
void file_output (struct car_results ** cars) {
	numbers t_final = max_t_exit(cars) + 5;		// Final timestamp of the simulation
												// When the last car exits + optional constant extra time

	numbers timestep = t_final/TIMESTAMP_NUM;		// Size of the timestep (units of time).
	
	FILE * fptr;
	fptr = fopen("inputs.txt","w");					// Open/create a new output file

	fprintf(fptr,"t px0 py0 px1 py1 px2 py2\n");	// First row is for headers
	
	int i;
	numbers time = 0;
	for(i=0; i<TIMESTAMP_NUM; i++) {			// For each timestep
		fprintf(fptr,"%f ",time);				// calculate and write positions for each car
		fprintf(fptr,"%.2f %.2f %.2f %.2f %.2f %.2f\n",
			get_x_at_t(cars[0],time),get_y_at_t(cars[0],time),
			get_x_at_t(cars[1],time),get_y_at_t(cars[1],time),
			get_x_at_t(cars[2],time),get_y_at_t(cars[2],time));
		time = time + timestep;
	}
	fclose(fptr);		// Close output file
}


int main() {

	// Create three cars
	struct car * all_cars[CAR_NUM];
	initialize_cars(all_cars);


	// Call and get outputs from 3 algorithms
	DU(all_cars, "DOWN");
	DU(all_cars, "LEFT");
	DU(all_cars, "RIGHT");


	// Parse 3 outputs from files and store items in arrays
	struct car_results * results [CAR_NUM]; 
	initialize_results(results);


	parse_results(all_cars, results);
	

	// Generate data from result arrays and write it to final file
	file_output(results);

	// free resources

	return 0;
} 




